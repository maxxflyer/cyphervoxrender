
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
        <video id="videoback" loop="true" style="position: absolute; left: 15px; top: 205px; display: none" src="" controls="true" autoplay="true" crossorigin="anonymous"></video> 
        <video id="videofront" loop="true" style="position: absolute; left: 15px; top: 205px; display: none" src="" controls="true" autoplay="true" crossorigin="anonymous"></video> 
        
        <script src="three.js"></script>
        <script type="module"> 

import * as THREE from 'https://unpkg.com/three/build/three.module.js'

import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js'

let camera, controls, scene, renderer, backtexture, fronttexture, videoback, videofront;


		
init();
render();

function init() {

    renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setClearColor(new THREE.Color(0xffffff, 1.0));
    renderer.shadowMapEnabled = true;
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild(renderer.domElement);
    camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 10 );
    camera.position.set( 0.175, 0.055, 0.075 );

    scene = new THREE.Scene();
    scene.add( camera );
    scene.background = new THREE.Color( "0xffffff" );

    
    
    
   // raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );
    //let material = new THREE.MeshPhongMaterial( { color: 0xb080b0, dithering: true } );
  
      
//let mesh = new THREE.Mesh( geometry, material );
//////mesh.position.set( 0, - 1, 0 );
//mesh.rotation.x = - Math.PI * 0.5;
//mesh.receiveShadow = true;
//scene.add( mesh );




    let uri
try{
var loader2 = new THREE.TextureLoader();
let im=getUrlVars()["cards"].split(",")[3]
if(im=="_")im=getUrlVars()["cards"].split(",")[1]
if(im!="_"){
    document.getElementById("videoback").setAttribute("src",im)


    videoback = document.getElementById('videoback');
    backtexture = new THREE.Texture(videoback);
    backtexture.minFilter = THREE.LinearFilter;
    backtexture.magFilter = THREE.LinearFilter;
    backtexture.format = THREE.RGBFormat;
    backtexture.generateMipmaps = false;

 
    let geometry = new THREE.PlaneGeometry( 0.1, 0.15 );
 // var geometry = new THREE.SphereGeometry(100, 20, 20);
  var material = new THREE.MeshBasicMaterial({map: backtexture});
  var back = new THREE.Mesh(geometry, material);

  back.position.set( 0, 0, 0 );
  back.rotation.x = - Math.PI * 0.5;
  back.rotation.y = - Math.PI * 0.5;
  back.rotation.z = - Math.PI * 0.5;
  back.receiveShadow = true;
 
  scene.add(back);

}else{

uri=im

if(uri.indexOf("ipfs")==0)
uri="https://ipfs.io/"+uri.substring(7)

loader2.load(uri, function ( texture ) {

    let geometry = new THREE.PlaneGeometry( 0.1, 0.15 );
 // var geometry = new THREE.SphereGeometry(100, 20, 20);
  var material = new THREE.MeshBasicMaterial({map: texture});
  var back = new THREE.Mesh(geometry, material);

  back.position.set( 0, 0, 0 );
  back.rotation.x = - Math.PI * 0.5;
  back.rotation.y = - Math.PI * 0.5;
  back.rotation.z = - Math.PI * 0.5;
  back.receiveShadow = true;
 
  scene.add(back);

});

}
}catch(e){}

let im=getUrlVars()["cards"].split(",")[2]
if(im=="_")im=getUrlVars()["cards"].split(",")[0]

if(im!="_"){
    document.getElementById("videofront").setAttribute("src",im)


    videofront = document.getElementById('videofront');
    fronttexture = new THREE.Texture(videofront);
    fronttexture.minFilter = THREE.LinearFilter;
    fronttexture.magFilter = THREE.LinearFilter;
    fronttexture.format = THREE.RGBFormat;
    fronttexture.generateMipmaps = false;

 
    let geometry = new THREE.PlaneGeometry( 0.1, 0.15 );
 // var geometry = new THREE.SphereGeometry(100, 20, 20);
  var material = new THREE.MeshBasicMaterial({map: fronttexture});
  var back = new THREE.Mesh(geometry, material);

  front.position.set( 0, 0, 0 );
  front.rotation.x = - Math.PI * 0.5;
  front.rotation.y = - Math.PI * 0.5;
  front.rotation.z = - Math.PI * 0.5;
  front.receiveShadow = true;
 
  scene.add(front);

}else{
uri=im

if(uri.indexOf("ipfs")==0)
uri="https://ipfs.io/"+uri.substring(7)
var loader2 = new THREE.TextureLoader();
loader2.load(uri, function ( texture ) {

    let geometry = new THREE.PlaneGeometry( 0.1, 0.15 );
 // var geometry = new THREE.SphereGeometry(100, 20, 20);
  var material = new THREE.MeshBasicMaterial({map: texture});
  
  var front = new THREE.Mesh(geometry, material);
 
  front.position.set( 0, 0, 0 );
  front.rotation.x = - Math.PI * 0.5;
  front.rotation.y =  Math.PI * 0.5;
  front.rotation.z =  Math.PI * 0.5;
  front.receiveShadow = true;
 
  scene.add(front);

});
}
    // light

    const hemiLight = new THREE.HemisphereLight( 0x888888, 0x444444, 1 );
    scene.add( hemiLight );

    const dirLight = new THREE.DirectionalLight( 0xffffff, 0.75 );
    dirLight.position.set( 1.5, 3, 2.5 );
    scene.add( dirLight );

    const dirLight2 = new THREE.DirectionalLight( 0xffffff, 0.5 );
    dirLight2.position.set( - 1.5, - 3, - 2.5 );
    scene.add( dirLight2 );

    
    

    controls = new OrbitControls( camera, renderer.domElement );
    controls.minDistance = 0.1;
    controls.maxDistance = 0.5;

    


}





function getUrlVars() {
    var vars = {};
    var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
        vars[key] = value;
    });
    return vars;
}

function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

function render() {
    
    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                  if (backtexture) backtexture.needsUpdate = true;
    }
   requestAnimationFrame(render);
              
    renderer.render( scene, camera );

}


		</script>
	</body>
</html>
